#!/usr/bin/env python3
import math


def analysisAndMove(cur_pos, end_pos):
    if cur_pos[0] < end_pos[0]: return 'MOVE RIGHT\n'
    if cur_pos[0] > end_pos[0]: return 'MOVE LEFT\n'
    if cur_pos[1] < end_pos[1]: return 'MOVE DOWN\n'
    if cur_pos[1] > end_pos[1]: return 'MOVE UP\n'


def findPath(cur_pos, res_pos, ava_move):
    guide = []

    direction = [(-1, 0), (0, -1), (1, 0), (0, 1)]
    path = {}
    r_path = {}

    order = 1
    path[order] = set()
    path[order].add(res_pos)

    temp_ava_move = list(ava_move)

    while cur_pos not in path[order]:
        order += 1
        path[order] = set()
        for pos in path[order - 1]:
            r_path[pos] = set()
            if pos in temp_ava_move:
                temp_ava_move.remove(pos)
            for d in direction:
                temp_pos = (pos[0] + d[0], pos[1] + d[1])
                if temp_pos in temp_ava_move:
                    path[order].add(temp_pos)
                    r_path[pos].add(temp_pos)

    search_key = cur_pos

    while search_key != res_pos:
        for key, values in r_path.items():
            for value in values:
                if value == search_key:
                    search_key = key
                    guide.append(search_key)
                    break
    return (guide, len(guide))


while True:
    x = input()
    if 'HELLO' in x:
        print('I AM QUI\n')
    if 'YOU ARE' in x:
        my_letter = x[-1]
        print('OK\n')
    if 'MAZE' in x:
        maze = []
        while len(x) > 0:
            x = input()
            maze.append(x)

        normal_resource = []
        rare_resource = []
        available_move = []

        for y in range(len(maze)):
            for x in range(len(maze[y])):
                if maze[y][x] == 'o':
                    normal_resource.append((x, y))
                if maze[y][x] == '!':
                    rare_resource.append((x, y))
                if maze[y][x] == my_letter:
                    current_pos = (x, y)
                if maze[y][x] != '#':
                    available_move.append((x, y))

        _min = [[], 1000000]
        for i in normal_resource:
            temp = findPath(current_pos, i, available_move)
            if temp[1] < _min[1]:
                _min[0] = temp[0]
                _min[1] = temp[1]
        print(analysisAndMove(current_pos, _min[0][0]))
